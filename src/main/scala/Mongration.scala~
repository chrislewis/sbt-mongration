package godcode

import mongration.json._
import sbt._
import com.mongodb._

trait Mongration extends Project {
  
  def configure: (Mongo, DB)
  lazy val (mongo_con, mongo_db) = configure
  
  def seed = "src" / "test" / "resources" / "seed.json"
  
  /* 2.7 collection implicits */
  import scala.collection.jcl.Conversions._
  
  import net.liftweb.json._
  import JsonAST._
  
  lazy val mongoCollections = task {
    mongo_db.getCollectionNames.foreach(log.info(_))
    None
  } describedAs("List collections in the current database.")
  
  lazy val mongoDrop = task {
    mongo_db.dropDatabase()
    None
  } describedAs("[!] Destroy the current database. Use with caution.")
  
  /* JObject => BasicDBObject */
  def cookOne(obj: JValue) = obj match {
    case o @ JObject(_) => Json.parseMongoDBObject(o)
  }
  
  /* JObject => (String, List[JValue]) */
  def baseCollections(obj: JValue): (String, List[JValue]) = obj match {
    case JObject(JField("collection", JString(collection)) :: JField("docs", JArray(jdocs)) :: Nil) =>
      (collection, jdocs)
  }
  
  /* List[JValue] => A => ((String, List[JValue])) => (String, A) */
  def cook[A](f: List[JValue] => A)(raw: (String, List[JValue])): (String, A) = raw match {
    case (collection, docs) => (collection, f(docs))
  }
  
  /* String => A => ((String, List[BasicDBObject])) => (String, A, List[BasicDBObject]))) */
  def augment[A](f: String => A)(col: (String, List[BasicDBObject])): (String, A, List[BasicDBObject]) = col match {
    case (name, objs) => (name, f(name), objs)
  }
  
  def woobs(col: (String, DBCollection, List[BasicDBObject])) = col match {
    case (name, col, docs) => docs.foreach(col.insert)
  }
  
  val wiii: ((String, List[BasicDBObject])) => Unit = {
    case (name, docs) =>
      val col = mongo_db.getCollection(name)
      log.info(" -- %s [%d documents]".format(name, docs.size))
      docs.foreach(col.insert)
  }
    
  
  lazy val mongoSeed = task {
    FileUtilities.readString(seed.asFile, log) match {
      case Left(err) => log.error(err)
      case Right(value) => JsonParser.parse(value) match {
        case JArray(values) =>
          /* List[JValue] => List[(String, List[BasicDBObject])] */
          values.map(baseCollections)
            .map(cook(_ map cookOne))
            .map(augment(mongo_db.getCollection))
            .map(woobs)
      }
    }
    
    None
  } describedAs("Populate the database with seed data.")
  
}

object Mongration {
  
  type Host = (String, Int)
  type Auth = (String, String)
  
  def configure(host: Host, database: String, auth: Auth) = (host, auth) match {
    case ((host, port), (user, password)) =>
      val m = new Mongo(host, port)
      val db = m.getDB(database)
      db.authenticate(user, password.toArray)
      (m, db)
  }
  
}
